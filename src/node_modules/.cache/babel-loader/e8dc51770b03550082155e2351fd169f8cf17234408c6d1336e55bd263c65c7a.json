{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useRef } from 'react';\nimport { useDrag, useDrop } from 'react-dnd';\nimport { ItemType } from '../utils/enums.ts';\nexport function useTaskDragAndDrop({\n  task,\n  index\n}, handleDropHover) {\n  _s();\n  const ref = useRef(null);\n  const [{\n    isDragging\n  }, drag] = useDrag({\n    item: {\n      from: task.column,\n      id: task.id,\n      index\n    },\n    type: ItemType.TASK,\n    collect: monitor => ({\n      isDragging: monitor.isDragging()\n    })\n  });\n  const [_, drop] = useDrop({\n    accept: ItemType.TASK,\n    hover: (item, monitor) => {\n      if (!ref.current) {\n        return;\n      }\n\n      // the tasks are not on the same column\n      if (item.from !== task.column) {\n        return;\n      }\n      const draggedItemIndex = item.index;\n      const hoveredItemIndex = index;\n\n      // we are swapping the task with itself\n      if (draggedItemIndex === hoveredItemIndex) {\n        return;\n      }\n      const isDraggedItemAboveHovered = draggedItemIndex < hoveredItemIndex;\n      const isDraggedItemBelowHovered = !isDraggedItemAboveHovered;\n\n      // get mouse coordinatees\n      const {\n        x: mouseX,\n        y: mouseY\n      } = monitor.getClientOffset();\n\n      // get hover item rectangle\n      const hoveredBoundingRect = ref.current.getBoundingClientRect();\n\n      // Get hover item middle height position\n      const hoveredMiddleHeight = (hoveredBoundingRect.bottom - hoveredBoundingRect.top) / 2;\n      const mouseYRelativeToHovered = mouseY - hoveredBoundingRect.top;\n      const isMouseYAboveHoveredMiddleHeight = mouseYRelativeToHovered < hoveredMiddleHeight;\n      const isMouseYBelowHoveredMiddleHeight = mouseYRelativeToHovered > hoveredMiddleHeight;\n\n      // Only perform the move when the mouse has crossed half of the items height\n      // When dragging downwards, only move when the cursor is below 50%\n      // When dragging upwards, only move when the cursor is above 50%\n\n      if (isDraggedItemAboveHovered && isMouseYAboveHoveredMiddleHeight) {\n        return;\n      }\n      if (isDraggedItemBelowHovered && isMouseYBelowHoveredMiddleHeight) {\n        return;\n      }\n\n      // Time to actually perform the action\n      handleDropHover(draggedItemIndex, hoveredItemIndex);\n\n      // Note: we're mutating the monitor item here!\n      // Generally it's better to avoid mutations,\n      // but it's good here for the sake of performance\n      // to avoid expensive index searches.\n      item.index = hoveredItemIndex;\n    }\n  });\n  drag(drop(ref));\n  return {\n    ref,\n    isDragging\n  };\n}\n_s(useTaskDragAndDrop, \"U59fjKKK+dUQYJp+GycGN/03OaY=\", false, function () {\n  return [useDrag, useDrop];\n});","map":{"version":3,"names":["useRef","useDrag","useDrop","ItemType","useTaskDragAndDrop","task","index","handleDropHover","_s","ref","isDragging","drag","item","from","column","id","type","TASK","collect","monitor","_","drop","accept","hover","current","draggedItemIndex","hoveredItemIndex","isDraggedItemAboveHovered","isDraggedItemBelowHovered","x","mouseX","y","mouseY","getClientOffset","hoveredBoundingRect","getBoundingClientRect","hoveredMiddleHeight","bottom","top","mouseYRelativeToHovered","isMouseYAboveHoveredMiddleHeight","isMouseYBelowHoveredMiddleHeight"],"sources":["/Users/jason/bizchina/src/dashboard/hooks/useTaskDragAndDrop.ts"],"sourcesContent":["import { useRef } from 'react';\nimport { useDrag, useDrop, XYCoord } from 'react-dnd';\nimport { ItemType } from '../utils/enums.ts';\nimport { DragItem, TaskModel } from '../utils/models.ts';\n\nexport function useTaskDragAndDrop<T extends HTMLElement>(\n  { task, index }: { task: TaskModel; index: number },\n  handleDropHover: (i: number, j: number) => void,\n) {\n  const ref = useRef<T>(null);\n\n  const [{ isDragging }, drag] = useDrag<\n    DragItem,\n    void,\n    { isDragging: boolean }\n  >({\n    item: { from: task.column, id: task.id, index },\n    type: ItemType.TASK,\n    collect: (monitor) => ({\n      isDragging: monitor.isDragging(),\n    }),\n  });\n\n  const [_, drop] = useDrop<DragItem, void, unknown>({\n    accept: ItemType.TASK,\n    hover: (item, monitor) => {\n      if (!ref.current) {\n        return;\n      }\n\n      // the tasks are not on the same column\n      if (item.from !== task.column) {\n        return;\n      }\n\n      const draggedItemIndex = item.index;\n      const hoveredItemIndex = index;\n\n      // we are swapping the task with itself\n      if (draggedItemIndex === hoveredItemIndex) {\n        return;\n      }\n\n      const isDraggedItemAboveHovered = draggedItemIndex < hoveredItemIndex;\n      const isDraggedItemBelowHovered = !isDraggedItemAboveHovered;\n\n      // get mouse coordinatees\n      const { x: mouseX, y: mouseY } = monitor.getClientOffset() as XYCoord;\n\n      // get hover item rectangle\n      const hoveredBoundingRect = ref.current.getBoundingClientRect();\n\n      // Get hover item middle height position\n      const hoveredMiddleHeight =\n        (hoveredBoundingRect.bottom - hoveredBoundingRect.top) / 2;\n\n      const mouseYRelativeToHovered = mouseY - hoveredBoundingRect.top;\n      const isMouseYAboveHoveredMiddleHeight =\n        mouseYRelativeToHovered < hoveredMiddleHeight;\n      const isMouseYBelowHoveredMiddleHeight =\n        mouseYRelativeToHovered > hoveredMiddleHeight;\n\n      // Only perform the move when the mouse has crossed half of the items height\n      // When dragging downwards, only move when the cursor is below 50%\n      // When dragging upwards, only move when the cursor is above 50%\n\n      if (isDraggedItemAboveHovered && isMouseYAboveHoveredMiddleHeight) {\n        return;\n      }\n\n      if (isDraggedItemBelowHovered && isMouseYBelowHoveredMiddleHeight) {\n        return;\n      }\n\n      // Time to actually perform the action\n      handleDropHover(draggedItemIndex, hoveredItemIndex);\n\n      // Note: we're mutating the monitor item here!\n      // Generally it's better to avoid mutations,\n      // but it's good here for the sake of performance\n      // to avoid expensive index searches.\n      item.index = hoveredItemIndex;\n    },\n  });\n\n  drag(drop(ref));\n\n  return {\n    ref,\n    isDragging,\n  };\n}\n"],"mappings":";AAAA,SAASA,MAAM,QAAQ,OAAO;AAC9B,SAASC,OAAO,EAAEC,OAAO,QAAiB,WAAW;AACrD,SAASC,QAAQ,QAAQ,mBAAmB;AAG5C,OAAO,SAASC,kBAAkBA,CAChC;EAAEC,IAAI;EAAEC;AAA0C,CAAC,EACnDC,eAA+C,EAC/C;EAAAC,EAAA;EACA,MAAMC,GAAG,GAAGT,MAAM,CAAI,IAAI,CAAC;EAE3B,MAAM,CAAC;IAAEU;EAAW,CAAC,EAAEC,IAAI,CAAC,GAAGV,OAAO,CAIpC;IACAW,IAAI,EAAE;MAAEC,IAAI,EAAER,IAAI,CAACS,MAAM;MAAEC,EAAE,EAAEV,IAAI,CAACU,EAAE;MAAET;IAAM,CAAC;IAC/CU,IAAI,EAAEb,QAAQ,CAACc,IAAI;IACnBC,OAAO,EAAGC,OAAO,KAAM;MACrBT,UAAU,EAAES,OAAO,CAACT,UAAU,CAAC;IACjC,CAAC;EACH,CAAC,CAAC;EAEF,MAAM,CAACU,CAAC,EAAEC,IAAI,CAAC,GAAGnB,OAAO,CAA0B;IACjDoB,MAAM,EAAEnB,QAAQ,CAACc,IAAI;IACrBM,KAAK,EAAEA,CAACX,IAAI,EAAEO,OAAO,KAAK;MACxB,IAAI,CAACV,GAAG,CAACe,OAAO,EAAE;QAChB;MACF;;MAEA;MACA,IAAIZ,IAAI,CAACC,IAAI,KAAKR,IAAI,CAACS,MAAM,EAAE;QAC7B;MACF;MAEA,MAAMW,gBAAgB,GAAGb,IAAI,CAACN,KAAK;MACnC,MAAMoB,gBAAgB,GAAGpB,KAAK;;MAE9B;MACA,IAAImB,gBAAgB,KAAKC,gBAAgB,EAAE;QACzC;MACF;MAEA,MAAMC,yBAAyB,GAAGF,gBAAgB,GAAGC,gBAAgB;MACrE,MAAME,yBAAyB,GAAG,CAACD,yBAAyB;;MAE5D;MACA,MAAM;QAAEE,CAAC,EAAEC,MAAM;QAAEC,CAAC,EAAEC;MAAO,CAAC,GAAGb,OAAO,CAACc,eAAe,CAAC,CAAY;;MAErE;MACA,MAAMC,mBAAmB,GAAGzB,GAAG,CAACe,OAAO,CAACW,qBAAqB,CAAC,CAAC;;MAE/D;MACA,MAAMC,mBAAmB,GACvB,CAACF,mBAAmB,CAACG,MAAM,GAAGH,mBAAmB,CAACI,GAAG,IAAI,CAAC;MAE5D,MAAMC,uBAAuB,GAAGP,MAAM,GAAGE,mBAAmB,CAACI,GAAG;MAChE,MAAME,gCAAgC,GACpCD,uBAAuB,GAAGH,mBAAmB;MAC/C,MAAMK,gCAAgC,GACpCF,uBAAuB,GAAGH,mBAAmB;;MAE/C;MACA;MACA;;MAEA,IAAIT,yBAAyB,IAAIa,gCAAgC,EAAE;QACjE;MACF;MAEA,IAAIZ,yBAAyB,IAAIa,gCAAgC,EAAE;QACjE;MACF;;MAEA;MACAlC,eAAe,CAACkB,gBAAgB,EAAEC,gBAAgB,CAAC;;MAEnD;MACA;MACA;MACA;MACAd,IAAI,CAACN,KAAK,GAAGoB,gBAAgB;IAC/B;EACF,CAAC,CAAC;EAEFf,IAAI,CAACU,IAAI,CAACZ,GAAG,CAAC,CAAC;EAEf,OAAO;IACLA,GAAG;IACHC;EACF,CAAC;AACH;AAACF,EAAA,CAtFeJ,kBAAkB;EAAA,QAMDH,OAAO,EAYpBC,OAAO;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}